//! Types that are internal to the `graphql` module. These types are used for
//! the API implementation but shouldn't be shared outside the module or exposed
//! in the GraphQL API.
//!
//! This also holds implementations (both plain and trait implementations) on
//! GraphQL types, because the implementations are only used within this module.

use crate::{
    error::{ApiError, ApiResult},
    graphql::{Cursor, Item, SpotifyUri},
    util::UserId,
};
use derive_more::Display;
use std::{backtrace::Backtrace, str::FromStr};

// ===== Node =====

// For some reason, rust-analyzer throws an error when you try to import `Node`,
// so we use the qualified path here for dev QoL
impl crate::graphql::Node {
    /// Get a unique ID for this node. Because Relay requires a top-level
    /// query field `node` that can take in a node ID of _any_ type and
    /// return the corresponding node, each ID has to transparently indicate
    /// which type it maps to, so that we know how to retrieve the node just
    /// via the ID. Different nodes come from different data sources, so we
    /// have to include the type name in the ID.
    ///
    /// IDs use the format `<node_type>_<value_id>_<user_id>`, where `value_id`
    /// is some string that unique indentifies the node **within its type**.
    /// For example, for an item node it could be the URI.
    pub fn id(&self, user_id: &UserId) -> juniper::ID {
        let node_type = self.node_type();
        let value_id = match self {
            Self::TaggedItemNode(node) => node.item.uri(),
            Self::TagNode(node) => &node.tag,
        };

        juniper::ID::new(format!("{}_{}_{}", node_type, value_id, user_id))
    }

    /// Map this node to its simplified [NodeType]. [NodeType] has all the same
    /// variants as the `Node` enum, but doesn't hold any values.
    pub fn node_type(&self) -> NodeType {
        match self {
            Self::TaggedItemNode(_) => NodeType::TaggedItemNode,
            Self::TagNode(_) => NodeType::TagNode,
        }
    }
}

/// A discriminants-only version of the [Node] enum that's generated by
/// `juniper-from-schema`. This contains one variant for every node type defined
/// in the API, and is used to generate and parse node IDs.
///
/// TODO replace with strum's `EnumDiscriminants` derive after https://github.com/davidpdrsn/juniper-from-schema/issues/139
#[derive(Copy, Clone, Debug, Display)]
pub enum NodeType {
    TaggedItemNode,
    TagNode,
}

impl NodeType {
    /// Parse a GraphQL node ID into its components. See
    /// [Node::id](crate::graphql::Node::id) for a description of the ID format.
    pub fn parse_id(id: &juniper::ID) -> ApiResult<(Self, String, UserId)> {
        match id.split('_').collect::<Vec<&str>>().as_slice() {
            [node_type, value_id, user_id] => Ok((
                node_type.parse()?,
                (*value_id).to_owned(),
                UserId((*user_id).to_owned()),
            )),
            _ => Err(ApiError::ParseError {
                message: format!("Invalid GraphQL node ID: {}", id),
                backtrace: Backtrace::capture(),
            }),
        }
    }
}

impl FromStr for NodeType {
    type Err = ApiError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TaggedItemNode" => Ok(NodeType::TaggedItemNode),
            "TagNode" => Ok(NodeType::TagNode),
            _ => Err(ApiError::ParseError {
                message: format!("Unknown GraphQL node type: {}", s),
                backtrace: Backtrace::capture(),
            }),
        }
    }
}

// ===== Item =====

impl Item {
    /// Get the URI for this item
    pub fn uri(&self) -> &SpotifyUri {
        match self {
            Self::Track(track) => &track.uri,
            Self::AlbumSimplified(album) => &album.uri,
            Self::Artist(artist) => &artist.uri,
        }
    }
}

// TODO consolidate impls on Item and other gql types
// TODO replace with derive after https://github.com/davidpdrsn/juniper-from-schema/issues/139
impl Clone for Item {
    fn clone(&self) -> Self {
        match self {
            Self::Track(track) => Self::Track(track.clone()),
            Self::AlbumSimplified(album) => {
                Self::AlbumSimplified(album.clone())
            }
            Self::Artist(artist) => Self::Artist(artist.clone()),
        }
    }
}

// ===== Generic Edge =====

/// Helper type to handle GQL edge types. Edges consist of a cursor, to locate
/// the edge within a Connection, and an associated node.
pub struct GenericEdge<N> {
    node: N,
    cursor: Cursor,
}

impl<N> GenericEdge<N> {
    pub fn node(&self) -> &N {
        &self.node
    }

    pub fn cursor(&self) -> &Cursor {
        &self.cursor
    }

    /// Convert a list of nodes into edges. The edges will keep the same
    /// ordering, and each edge will be generated a cursor based on the given
    /// offset plus that edge's location in the list.
    pub fn from_nodes(
        rows: impl Iterator<Item = N>,
        offset: usize,
    ) -> Vec<Self> {
        rows.enumerate()
            .map(|(index, node)| Self {
                node,
                cursor: Cursor::from_offset_index(offset, index),
            })
            .collect()
    }
}
